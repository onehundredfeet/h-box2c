
abstract ShapeId(int64) {

};


/// Used to create a shape
[Internal="hbox2c::ShapeDef"]
object ShapeDef
{
	ShapeDef new();

	// friction = 0.6f;
	// density = 1.0f;
	// filter = b2DefaultFilter();
	// enableSensorEvents = true;
	// enableContactEvents = true;

	void clear(); // reset to defaults

	/// Use this to store application specific shape data.
	[Get="cast"] attribute dynamic userData;

	/// The friction coefficient, usually in the range [0,1].
	attribute float friction;

	/// The restitution (bounce) usually in the range [0,1].
	attribute float restitution;

	/// The density, usually in kg/m^2.
	attribute float density;

	/// Contact filtering data.
	/// The collision category bits. Normally you would just set one bit.
	[Internal="filter.categoryBits"] attribute uint categoryBits;

	/// The collision mask bits. This states the categories that this
	/// shape would accept for collision.	
	[Internal="filter.maskBits"] attribute uint maskBits;

	/// Collision groups allow a certain group of objects to never collide (negative)
	/// or always collide (positive). Zero means no collision group. Non-zero group
	/// filtering always wins against the mask bits.
	[Internal="filter.groupIndex"] attribute int groupIndex;

	/// A sensor shape collects contact information but never generates a collision response.
	attribute bool isSensor;

	/// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableSensorEvents;

	/// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableContactEvents;

	/// Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableHitEvents;

	/// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
	///	and must be carefully handled due to multi-threading. Ignored for sensors.
	attribute bool enablePreSolveEvents;

	/// Normally shapes on static bodies don't invoke contact creation when they are added to the world. This overrides
	///	that behavior and causes contact creation. This significantly slows down static body creation which can be important
	///	when there are many static bodies.
	attribute bool forceContactCreation;

} ;

[Internal="b2Transform"]
object Transform {
	Transform new();

	[Internal="p.x"] attribute float x; 
	[Internal="p.y"] attribute float y;
	[Internal="q.c"] attribute float c; // cos
	[Internal="q.s"] attribute float s; // sin
};

[Internal="hb2BodyId"]
abstract Body(int64) {
	/// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.
	/// Contacts are not created until the next time step.
	///	@return the shape id for accessing the shape
	[ Internal="hbox2c::Body::CreateCircleShape"] ShapeId createCircleShape( ShapeDef *def, float center_x, float center_y, float radius);

	/// Set the world transform of a body. This acts as a teleport and is fairly expensive.
	[ Internal="hbox2c::Body::SetTransform"] void setTransform(float position_x, float position_y, float angle);
	[ Internal="hbox2c::Body::SetTransformF"] void setTransformF(double2 position, float angle);


	[ Internal="hbox2c::Body::GetTransform"] void getTransform(Transform *transform);
	[ Internal="hbox2c::Body::GetTransformAsArray"] void getTransformAsArray(float [] transform); // 4 floats

};

[Internal="hb2WorldId"]
abstract World(int) {
	[Internal="hb2DestroyWorld"] void destroy();
	[Internal="hb2CreateBody"] Body createBody(BodyDef *def);

};




abstract QueryFilter(int64) {

};

//typedef WorldId uint;
//typedef ShapeId int64;
//typedef Body int64;
//typedef QueryFilter int64;

/// The body type.
/// static: zero mass, zero velocity, may be manually moved
/// kinematic: zero mass, non-zero velocity set by user, moved by solver
/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver
[Internal="b2BodyType", Prefix="b2_"]
enum BodyType
{
	staticBody,
	kinematicBody,
	dynamicBody
};


[Internal="b2AABB"]
object AABB {
	AABB new();
	[Internal="lowerBound.x"] attribute float lowerBound_x;
	[Internal="lowerBound.y"] attribute float lowerBound_y;
	[Internal="upperBound.x"] attribute float upperBound_x;
	[Internal="upperBound.y"] attribute float upperBound_y;
};




[NoDelete, Internal="b2BodyMoveEvent"]
object BodyMoveEvent
{
	[Internal="transform.p.x"] attribute float pos_x;
	[Internal="transform.p.y"] attribute float pos_y;
	[Internal="transform.q.c"] attribute float quat_c;
	[Internal="transform.q.s"] attribute float quat_s;
	[Get="cast", Set="castBodyId"] attribute Body body;
	[Get="cast"] attribute dynamic userData;
	attribute bool fellAsleep;
};

/// Body events are buffered in the Box2D world and are available
///	as event arrays after the time step is complete.
///	Note: this date becomes invalid if bodies are destroyed
[Internal="hbox2c::BodyEvents"]
object BodyEvents
{
	void getMove( int i, BodyMoveEvent moveEvent);
	attribute int moveCount;
};


/// A begin touch event is generated when a shape starts to overlap a sensor shape.
[NoDelete, Internal="hbox2c::SensorBeginTouchEvent"]
object SensorBeginTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId sensorShapeId;
	[Get="cast", Set="castShapeId"] attribute ShapeId visitorShapeId;
};

/// An end touch event is generated when a shape stops overlapping a sensor shape.
[NoDelete, Internal="hbox2c::SensorEndTouchEvent"]
object SensorEndTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId sensorShapeId;
	[Get="cast", Set="castShapeId"] attribute ShapeId visitorShapeId;
};

/// Sensor events are buffered in the Box2D world and are available
///	as begin/end overlap event arrays after the time step is complete.
///	Note: these may become invalid if bodies and/or shapes are destroyed
[Internal="hbox2c::SensorEvents"]
object SensorEvents
{
	SensorEvents new();

	void getBegin( int i, SensorBeginTouchEvent event);
	void getEnd( int i, SensorEndTouchEvent event);

	attribute int beginCount;
	attribute int endCount;
} ;

[NoDelete]
object QueryFunc {
	[Static, Internal="b2DefaultQueryFilter", Get="cast"] QueryFilter getDefault();

	/// The collision category bits. Normally you would just set one bit.
	[Static] int getCategoryBits(QueryFilter filter);
	
	/// The collision mask bits. This states the categories that this
	/// shape would accept for collision.
	[Static] int getMaskBits(QueryFilter filter);

	/// The collision mask bits. This states the categories that this
	/// shape would accept for collision.
	[Static] QueryFilter makeQueryFilter(int categoryBits, int maskBits);



};

/// A begin touch event is generated when two shapes begin touching. By convention the manifold
/// normal points from shape A to shape B.
[NoDelete, Internal="b2ContactBeginTouchEvent"]
object ContactBeginTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;
} ;

/// An end touch event is generated when two shapes stop touching.
[NoDelete, Internal="b2ContactEndTouchEvent"]
object ContactEndTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;
} ;

/// A hit touch event is generated when two shapes collide with a speed faster than the hit speed threshold.
[NoDelete, Internal="hbox2c::ContactHitEvent"]
object ContactHitEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;

	// point where the shapes hit
	//b2Vec2 point;
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;

	// normal vector pointing from shape A to shape B
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.y"] attribute float normal_y;

	attribute float approachSpeed;
} ;

/// Contact events are buffered in the Box2D world and are available
///	as event arrays after the time step is complete.
///	Note: these may become invalid if bodies and/or shapes are destroyed
[Internal="hbox2c::ContactEvents"]
object ContactEvents
{
	void getBegin( int i, ContactBeginTouchEvent event);
	void getEnd( int i, ContactEndTouchEvent event);
	void getHit( int i, ContactHitEvent event);

	attribute int beginCount;
	attribute int endCount;
	attribute int hitCount;
} ;

[Internal="hbox2c::RayResult"]
object RayResult
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeId;
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.y"] attribute float normal_y;
	attribute float fraction;
	attribute bool hit;
};

[Internal="hbox2c::Hull"]
object Hull 
{
	Hull new();

	void fromPoints(float [] points, int count);
    bool isValid();
};

[Internal="hbox2c::Polygon"]
object Polygon 
{
	Polygon new();

	/// Make a convex polygon from a convex hull. This will assert if the hull is not valid.
	bool fromHull(Hull hull, float radius);

	/// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.
	bool fromOffsetHull(Hull hull, float radius, float transform_x, float transform_y, float transform_rot );

	/// Make a square polygon, bypassing the need for a convex hull.
	bool makeSquare(float h);

	/// Make a box (rectangle) polygon, bypassing the need for a convex hull.
	bool makeBox(float hx, float hy);

	/// Make a rounded box, bypassing the need for a convex hull.
	bool makeRoundedBox(float hx, float hy, float radius);

	/// Make an offset box, bypassing the need for a convex hull.
	bool makeOffsetBox(float hx, float hy, float center_x, float center_y, float angle);

	/// Transform a polygon. This is useful for transferring a shape from one body to another.
	bool fromTransformedPolygon(float transform_x, float transform_y, float transform_rot, Polygon polygon);

	// Translate polygon
	void translate( float x, float y);
};

/// A body definition holds all the data needed to construct a rigid body.
/// You can safely re-use body definitions. Shapes are added to a body after construction.
[Internal="hbox2c::BodyDef"]
object BodyDef {
	BodyDef new();
	
	/// The body type: static, kinematic, or dynamic.
	/// Note: if a dynamic body would have zero mass, the mass is set to one.
	attribute BodyType type;

	/// The world position of the body. Avoid creating bodies at the origin
	/// since this can lead to many overlapping shapes.
	void setPosition( float x, float y);

	/// The world angle of the body in radians.
	attribute float angle;

	/// The linear velocity of the body's origin in world co-ordinates.
	void setLinearVelocity( float x, float y);

	/// The angular velocity of the body.
	attribute float angularVelocity;

	/// Linear damping is use to reduce the linear velocity. The damping parameter
	/// can be larger than 1.0f but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	attribute float linearDamping;

	/// Angular damping is use to reduce the angular velocity. The damping parameter
	/// can be larger than 1.0f but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	attribute float angularDamping;

	/// Scale the gravity applied to this body.
	attribute float gravityScale;

	/// Sleep velocity threshold, default is 0.05 meter per second
	attribute float sleepThreshold;

	/// Use this to store application specific body data.
	void setUserData( dynamic data );

	/// Set this flag to false if this body should never fall asleep. Note that
	/// this increases CPU usage.
	attribute bool enableSleep;

	/// Is this body initially awake or sleeping?
	attribute bool isAwake;

	/// Should this body be prevented from rotating? Useful for characters.
	attribute bool fixedRotation;

	/// Treat this body as high speed object that performs continuous collision detection
	/// against dynamic and kinematic bodies, but not other bullet bodies.
	attribute bool isBullet;

	/// Does this body start out enabled?
	attribute bool isEnabled;

	/// Automatically compute mass and related properties on this body from shapes.
	/// Triggers whenever a shape is add/removed/changed. Default is true.
	attribute bool automaticMass;

};


namespace ShapeFunc {
	/// Destroy any shape type
	 [ Internal="hbox2c::Body::DestroyShape"] void destroyShape([Get="castShapeId"]ShapeId shapeId);

	[Internal="b2Shape_IsValid"] bool isValid([Get="castShapeId"] ShapeId id);
};


namespace BodyFunc {



/// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[ Internal="hbox2c::Body::CreateSegmentShape", Get="cast"] ShapeId createSegmentShape([Get="castBodyId"] Body Body, ShapeDef def, float point_1_x, float point_1_y, float point_2_x, float point_2_y);

/// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[ Internal="hbox2c::Body::CreateCapsuleShape", Get="cast"] ShapeId createCapsuleShape([Get="castBodyId"] Body Body, ShapeDef def, float center_1_x, float center_1_y, float center_2_x, float center_2_y, float radius);

/// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[ Internal="b2CreatePolygonShape", Get="cast"] ShapeId createPolygonShape([Get="castBodyId"] Body Body, ShapeDef def, Polygon polygon);
 
/// Body identifier validation. Provides validation for up to 64K allocations.
[ Internal="b2Body_IsValid"] bool isValid([Get="castBodyId"] Body id);

/// Get the body type:  kinematic, or dynamic
[ Internal="b2Body_GetType"] BodyType getType([Get="castBodyId"] Body Body);

/// Change the body type. This is an expensive operation. This automatically updates the mass
///	properties regardless of the automatic mass setting.
[ Internal="b2Body_SetType"] void setType([Get="castBodyId"] Body Body, BodyType type);

/// Set the user data for a body
[ Internal="b2Body_SetUserData"] void setUserData([Get="castBodyId"] Body Body, dynamic userData);

/// Get the user data stored in a body
[ Internal="b2Body_GetUserData", Get="cast"] dynamic getUserData([Get="castBodyId"] Body Body);

/// Get the world position of a body. This is the location of the body origin.
[ Internal="hbox2c::Body::GetPosition"] void getPosition([Get="castBodyId"] Body Body, float2 o_position);

/// Get the world rotation of a body as a sine/cosine pair.
[ Internal="hbox2c::Body::GetRotation"] void getRotation([Get="castBodyId"] Body Body, float2 quat);

/// Get the body angle in radians in the range [-pi, pi]
[ Internal="b2Body_GetAngle"] float getAngle([Get="castBodyId"] Body Body);

/// Get the world transform of a body.
[ Internal="hbox2c::Body::GetTransform"] void getTransform([Get="castBodyId"] Body Body, Transform transform);
[ Internal="hbox2c::Body::GetTransformAsArray"] void getTransformAsArray([Get="castBodyId"] Body Body, float [] transform); // 3 floats


/// Get a local point on a body given a world point
[ Internal="hbox2c::Body::GetLocalPoint"] void getLocalPoint([Get="castBodyId"] Body Body, float worldPoint_x, float worldPoint_y, float2 o_position );

/// Get a world point on a body given a local point
[ Internal="hbox2c::Body::GetWorldPoint"] void getWorldPoint([Get="castBodyId"] Body Body, float localPoint_x, float localPoint_y, float2 o_position );

/// Get a local vector on a body given a world vector
[ Internal="hbox2c::Body::GetLocalVector"] void getLocalVector([Get="castBodyId"] Body Body, float worldVector_x, float worldVector_y, float2 o_vector );

/// Get a world vector on a body given a local vector
[ Internal="hbox2c::Body::GetWorldVector"] void getWorldVector([Get="castBodyId"] Body Body, float localVector_x, float localVector_y, float2 o_vector );

/// Get the linear velocity of a body's center of mass
[ Internal="hbox2c::Body::GetLinearVelocity"] void getLinearVelocity([Get="castBodyId"] Body Body, float2 o_velocity);
[ Internal="hbox2c::Body::GetLinearVelocityAsArray"] void getLinearVelocityAsArray([Get="castBodyId"] Body Body, float [] o_velocity);
[ Internal="hbox2c::Body::GetLinearVelocityS"] void getLinearVelocityS([Get="castBodyId"] Body Body, float2 o_velocity);
[ Internal="hbox2c::Body::GetLinearVelocityF"] void getLinearVelocityF([Get="castBodyId"] Body Body, double2 o_velocity);

/// Get the angular velocity of a body in radians per second
[ Internal="b2Body_GetAngularVelocity"] float getAngularVelocity([Get="castBodyId"] Body Body);

/// Set the linear velocity of a body
[ Internal="hbox2c::Body::SetLinearVelocity"] void setLinearVelocity([Get="castBodyId"] Body Body, float linearVelocity_x, float linearVelocity_y);

/// Set the angular velocity of a body in radians per second
[ Internal="b2Body_SetAngularVelocity"] void setAngularVelocity([Get="castBodyId"] Body Body, float angularVelocity);

/// Apply a force at a world point. If the force is not
/// applied at the center of mass, it will generate a torque and
/// affect the angular velocity. This wakes up the body.
/// @param force the world force vector, usually in Newtons (N).
/// @param point the world position of the point of application.
/// @param wake also wake up the body
[ Internal="hbox2c::Body::ApplyForce"] void applyForce([Get="castBodyId"]Body Body, float force_x, float force_y,  float point_x, float point_y, bool wake);

/// Apply a force to the center of mass. This wakes up the body.
/// @param force the world force vector, usually in Newtons (N).
/// @param wake also wake up the body
[ Internal="hbox2c::Body::ApplyForceToCenter"] void applyForceToCenter([Get="castBodyId"]Body Body, float force_x, float force_y, bool wake);

/// Apply a torque. This affects the angular velocity
/// without affecting the linear velocity of the center of mass.
/// @param torque about the z-axis (out of the screen), usually in N-m.
/// @param wake also wake up the body
[ Internal="b2Body_ApplyTorque"] void applyTorque([Get="castBodyId"]Body Body, float torque, bool wake);

/// Apply an impulse at a point. This immediately modifies the velocity.
/// It also modifies the angular velocity if the point of application
/// is not at the center of mass. This wakes up the body.
/// This should be used for one-shot impulses. If you need a steady force,
/// use a force instead, which will work better with the sub-stepping solver.
/// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
/// @param point the world position of the point of application.
/// @param wake also wake up the body
[ Internal="hbox2c::Body::ApplyLinearImpulse"] void applyLinearImpulse([Get="castBodyId"]Body Body, float impulse_x, float impulse_y, float point_x, float point_y, bool wake);

/// Apply an impulse to the center of mass. This immediately modifies the velocity.
/// This should be used for one-shot impulses. If you need a steady force,
/// use a force instead, which will work better with the sub-stepping solver.
/// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
/// @param wake also wake up the body
[ Internal="hbox2c::Body::ApplyLinearImpulseToCenter"] void applyLinearImpulseToCenter([Get="castBodyId"]Body Body, float impulse_x, float impulse_y, bool wake);

/// Apply an angular impulse.
/// This should be used for one-shot impulses. If you need a steady force,
/// use a force instead, which will work better with the sub-stepping solver.
/// @param impulse the angular impulse in units of
/// kg*m*m/s
/// @param wake also wake up the body
[ Internal="b2Body_ApplyAngularImpulse"] void applyAngularImpulse([Get="castBodyId"]Body Body, float impulse, bool wake);

/// Get the mass of the body (kilograms)
[ Internal="b2Body_GetMass"] float getMass([Get="castBodyId"]Body Body);

/// Get the inertia tensor of the body. In 2D this is a single number. (kilograms * meters^2)
[ Internal="b2Body_GetInertiaTensor"] float getInertiaTensor([Get="castBodyId"]Body Body);

/// Get the center of mass position of the body in local space.
[ Internal="hbox2c::Body::GetLocalCenterOfMass"] void getLocalCenterOfMass([Get="castBodyId"]Body Body, float2 o_centerOfMass);

/// Get the center of mass position of the body in world space.
[ Internal="hbox2c::Body::GetWorldCenterOfMass"] void getWorldCenterOfMass([Get="castBodyId"]Body Body, float2 o_centerOfMass);

/// Override the body's mass properties. Normally this is computed automatically using the
///	shape geometry and density. This information is lost if a shape is added or removed or if the
///	body type changes.
//[ Internal="b2Body_SetMassData"] void SetMassData([Get="castBodyId"]Body Body, b2MassData massData);

/// Get the mass data for a body.
//[ Internal="b2Body_GetMassData"] b2MassData GetMassData([Get="castBodyId"]Body Body);

/// This resets the mass properties to the sum of the mass properties of the shapes.
/// This normally does not need to be called unless you called SetMassData to override
/// the mass and you later want to reset the mass.
///	You may also use this when automatic mass computation has been disabled.
///	You should call this regardless of body type.
[ Internal="b2Body_ApplyMassFromShapes"] void applyMassFromShapes([Get="castBodyId"] Body Body);

/// Set the automatic mass setting.
//[ Internal="b2Body_SetAutomaticMass"] void setAutomaticMass([Get="castBodyId"]Body Body, bool automaticMass);

/// Get the automatic mass setting.
//[ Internal="b2Body_GetAutomaticMass"] bool getAutomaticMass([Get="castBodyId"]Body Body);

/// Adjust the linear damping. Normally this is set in b2BodyDef before creation.
[ Internal="b2Body_SetLinearDamping"] void SetLinearDamping([Get="castBodyId"]Body Body, float linearDamping);

/// Get the current linear damping.
[ Internal="b2Body_GetLinearDamping"] float getLinearDamping([Get="castBodyId"]Body Body);

/// Adjust the angular damping. Normally this is set in b2BodyDef before creation.
[ Internal="b2Body_SetAngularDamping"] void SetAngularDamping([Get="castBodyId"]Body Body, float angularDamping);

/// Get the current angular damping.
[ Internal="b2Body_GetAngularDamping"] float getAngularDamping([Get="castBodyId"]Body Body);

/// Adjust the gravity scale. Normally this is set in b2BodyDef before creation.
[ Internal="b2Body_SetGravityScale"] void SetGravityScale([Get="castBodyId"]Body Body, float gravityScale);

/// Get the current gravity scale.
[ Internal="b2Body_GetGravityScale"] float getGravityScale([Get="castBodyId"]Body Body);

/// Is this body awake?
[ Internal="b2Body_IsAwake"] bool isAwake([Get="castBodyId"]Body Body);

/// Wake a body from sleep. This wakes the entire island the body is touching.
///	Putting a body to sleep will put the entire island of bodies touching this body to sleep,
///	which can be expensive.
[ Internal="b2Body_SetAwake"] void setAwake([Get="castBodyId"]Body Body, bool awake);

/// Enable or disable sleeping this body. If sleeping is disabled the body will wake.
[ Internal="b2Body_EnableSleep"] void enableSleep([Get="castBodyId"]Body Body, bool enableSleep);

/// @return is sleeping enabled for this body?
[ Internal="b2Body_IsSleepEnabled"] bool isSleepEnabled([Get="castBodyId"]Body Body);

/// Set the sleep threshold. Normally in meters per second.
[ Internal="b2Body_SetSleepThreshold"] void setSleepThreshold([Get="castBodyId"]Body Body, float sleepVelocity);

/// Get the sleep threshold. Normally in meters per second.
[ Internal="b2Body_GetSleepThreshold"] float getSleepThreshold([Get="castBodyId"]Body Body);

/// Is this body enabled?
[ Internal="b2Body_IsEnabled"] bool isEnabled([Get="castBodyId"]Body Body);

/// Disable a body by removing it completely from the simulation
[ Internal="b2Body_Disable"] void disable([Get="castBodyId"]Body Body);

/// Enable a body by adding it to the simulation
[ Internal="b2Body_Enable"] void enable([Get="castBodyId"]Body Body);

/// Set this body to have fixed rotation. This causes the mass to be reset in all cases.
[ Internal="b2Body_SetFixedRotation"] void setFixedRotation([Get="castBodyId"]Body Body, bool flag);

/// Does this body have fixed rotation?
[ Internal="b2Body_IsFixedRotation"] bool isFixedRotation([Get="castBodyId"]Body Body);

/// Set this body to be a bullet. A bullet does continuous collision detection
/// against dynamic bodies (but not other bullets).
[ Internal="b2Body_SetBullet"] void setBullet([Get="castBodyId"]Body Body, bool flag);

/// Is this body a bullet?
[ Internal="b2Body_IsBullet"] bool isBullet([Get="castBodyId"]Body Body);

/// Enable/disable hit events on all shapes.
[ Internal="b2Body_EnableHitEvents"] void enableHitEvents([Get="castBodyId"]Body Body, bool enableHitEvents);

/// Get the number of shapes on this body
[ Internal="b2Body_GetShapeCount"] int getShapeCount([Get="castBodyId"]Body Body);

/// Get the shape ids for all shapes on this body, up to the provided capacity.
///	@returns the number of shape ids stored in the user array
//[ Internal="b2Body_GetShapes"] int getShapes([Get="castBodyId"]Body Body, b2ShapeId* shapeArray, int capacity);

/// Get the number of joints on this body
[ Internal="b2Body_GetJointCount"] int getJointCount([Get="castBodyId"]Body Body);

/// Get the joint ids for all joints on this body, up to the provided capacity
///	@returns the number of joint ids stored in the user array
//[ Internal="b2Body_GetJoints"] int getJoints([Get="castBodyId"]Body Body, b2JointId* jointArray, int capacity);

/// Get the maximum capacity required for retrieving all the touching contacts on a body
[ Internal="b2Body_GetContactCapacity"] int getContactCapacity([Get="castBodyId"]Body Body);

/// Get the touching contact data for a body
//[ Internal="b2Body_GetContactData"] int getContactData([Get="castBodyId"]Body Body, b2ContactData* contactData, int capacity);

/// Get the current world AABB that contains all the attached shapes. Note that this may not emcompass the body origin.
///	If there are no shapes attached then the returned AABB is empty and centered on the body origin.
[ Internal="hbox2c::Body::ComputeAABB"] void computeAABB([Get="castBodyId"]Body Body, AABB aabb);

};



/// Shape type
[Internal="b2ShapeType", Prefix="b2_"]
enum ShapeType
{
	circleShape,
	capsuleShape,
	segmentShape,
	polygonShape,
	smoothSegmentShape,
	shapeTypeCount
} ;

/// This holds contact filtering data.
object b2Filter
{
	/// The collision category bits. Normally you would just set one bit.
	attribute uint categoryBits;

	/// The collision mask bits. This states the categories that this
	/// shape would accept for collision.
	attribute uint maskBits;

	/// Collision groups allow a certain group of objects to never collide (negative)
	/// or always collide (positive). Zero means no collision group. Non-zero group
	/// filtering always wins against the mask bits.
	attribute int groupIndex;
};



/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
[NoDelete, Internal="hbox2c::ManifoldPoint"]
object ManifoldPoint
{
	/// Location of the contact point in world space. Subject to precision loss at large coordinates.
	///	@warning should only be used for debugging.
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;

	/// Location of contact point relative to body origin in world space.
	///	@warning when used internally to the Box2D solver, these are relative to the center of mass.
	[Internal="anchorA.x"] attribute float anchorA_x;
	[Internal="anchorA.y"] attribute float anchorA_y;
	[Internal="anchorB.x"] attribute float anchorB_x;
	[Internal="anchorB.y"] attribute float anchorB_y;

	/// the separation of the contact point, negative if penetrating
	attribute float separation;

	/// the non-penetration impulse
	attribute float normalImpulse;

	/// the friction impulse
	attribute float tangentImpulse;

	/// the maximum normal impulse applied during sub-stepping
	///	todo not sure this is needed
	attribute float maxNormalImpulse;

	/// Relative normal velocity pre-solve. Used for hit events. If the normal impulse is
	/// zero then there was no hit. Negative means shapes are approaching.
	attribute float normalVelocity;

	/// uniquely identifies a contact point between two shapes
	attribute int id;

	/// Did this contact point exist the previous step?
	attribute bool persisted;
} ;

/// Contact manifold convex shapes.
[Internal="hbox2c::Manifold"]
object Manifold
{
	[AddressOf, ReadOnly, Const, Internal="points[0]", GetCast="hbox2c::ManifoldPoint*"] attribute ManifoldPoint points0;
	[AddressOf, ReadOnly, Const, Internal="points[1]", GetCast="hbox2c::ManifoldPoint*"] attribute ManifoldPoint points1;
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.x"] attribute float normal_y;
	attribute int pointCount;
} ;


/// Prototype for a pre-solve callback.
/// This is called after a contact is updated. This allows you to inspect a
/// contact before it goes to the solver. If you are careful, you can modify the
/// contact manifold (e.g. disable contact).
/// Notes:
///	- this function must be thread-safe
///	- this is only called if the shape has enabled presolve events
/// - this is called only for awake dynamic bodies
/// - this is not called for sensors
/// - the supplied manifold has impulse values from the previous step
///	Return false if you want to disable the contact this step
//typedef bool b2PreSolveFcn(b2ShapeId shapeIdA, b2ShapeId shapeIdB, b2Manifold* manifold, void* context);

//bool (ShapeId shapeIdA, ShapeId shapeIdB, Manifold manifold, dynamic context) PreSolveFcn

namespace WorldFunc {

/// Destroy a world.
/// [ Internal="b2DestroyWorld"] void destroy([Get="castWorldId"] WorldId worldId);
/// 
/// /// World identifier validation. Provides validation for up to 64K allocations.
/// [ Internal="b2World_IsValid"] bool isValid([Get="castWorldId"] WorldId id);
/// 
/// 
/// /// Call this to draw shapes and other debug draw data. This is intentionally non-const.
/// //[ Internal="b2World_Draw"] void draw([Get="castWorldId"] WorldId worldId, b2DebugDraw* draw);
/// 
/// /// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.
/// [ Internal="hbox2c::World::GetBodyEvents"] void getBodyEvents([Get="castWorldId"]WorldId worldId, BodyEvents events);
/// 
/// /// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.
/// [ Internal="hbox2c::World::GetSensorEvents"] void getSensorEvents([Get="castWorldId"]WorldId worldId, SensorEvents sensorEvents);
/// 
/// /// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.
/// [ Internal="hbox2c::World::GetContactEvents"] void getContactEvents([Get="castWorldId"]WorldId worldId, ContactEvents contactEvents);
/// 
/// /// Overlap test for all shapes that *potentially* overlap the provided AABB.
/// [ Internal="hbox2c::World::OverlapAABB"] void overlapAABB([Get="castWorldId"]WorldId worldId, float min_x, float min_y, float max_x, float max_y, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// /// Overlap test for for all shapes that overlap the provided circle.
/// [ Internal="hbox2c::World::OverlapCircle"] void overlapCircle([Get="castWorldId"]WorldId worldId, float x, float y, float radius,  Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);
/// 
/// /// Overlap test for all shapes that overlap the provided capsule.
/// //[ Internal="hbox2c::World::OverlapCapsule"] void overlapCapsule([Get="castWorldId"] WorldId worldId, const b2Capsule* capsule, Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);
/// 
/// /// Overlap test for all shapes that overlap the provided polygon.
/// //[ Internal="hbox2c::World::OverlapPolygon"] void overlapPolygon([Get="castWorldId"] WorldId worldId, const b2Polygon* polygon, Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);
/// 
/// /// Ray-cast the world for all shapes in the path of the ray. Your callback
/// /// controls whether you get the closest point, any point, or n-points.
/// /// The ray-cast ignores shapes that contain the starting point.
/// /// @param callback a user implemented callback class.
/// /// @param point1 the ray starting point
/// /// @param point2 the ray ending point
/// [ Internal="hbox2c::World::RayCast"] void rayCast([Get="castWorldId"] WorldId worldId, float x, float y, float dx, float dy, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);
/// 
/// /// Ray-cast closest hit. Convenience function. This is less general than b2World_RayCast and does not allow for custom filtering.
/// [ Internal="hbox2c::World::RayCastClosest"] bool rayCastClosest([Get="castWorldId"] WorldId worldId, float origin_x, float origin_y, float translation_x, float translation_y, [Get="castQueryFilter"] QueryFilter filter, RayResult result);
/// 
/// /// Cast a circle through the world. Similar to a ray-cast except that a circle is cast instead of a point.
/// [ Internal="hbox2c::World::CircleCast"] void circleCast([Get="castWorldId"] WorldId worldId, float x, float y, float radius, float ox, float oy, float rot, float dx, float dy,[Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);
/// 
/// /// Cast a capsule through the world. Similar to a ray-cast except that a capsule is cast instead of a point.
/// //[ Internal="b2World_CapsuleCast"] void capsuleCast([Get="castWorldId"] WorldId worldId, const b2Capsule* capsule, Transform originTransform, b2Vec2 translation, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);
/// 
/// /// Cast a capsule through the world. Similar to a ray-cast except that a polygon is cast instead of a point.
/// //[ Internal="b2World_PolygonCast"] void polygonCast([Get="castWorldId"] WorldId worldId, const b2Polygon* polygon, Transform originTransform, b2Vec2 translation, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);
/// 
/// /// Enable/disable sleep. Advanced feature for testing.
/// [ Internal="b2World_EnableSleeping"] void enableSleeping([Get="castWorldId"] WorldId worldId, bool flag);
/// 
/// /// Enable/disable constraint warm starting. Advanced feature for testing.
/// [ Internal="b2World_EnableWarmStarting"] void enableWarmStarting([Get="castWorldId"] WorldId worldId, bool flag);
/// 
/// /// Enable/disable continuous collision. Advanced feature for testing.
/// [ Internal="b2World_EnableContinuous"] void enableContinuous([Get="castWorldId"] WorldId worldId, bool flag);
/// 
/// /// Adjust the restitution threshold. Advanced feature for testing.
/// [ Internal="b2World_SetRestitutionThreshold"] void setRestitutionThreshold([Get="castWorldId"] WorldId worldId, float value);
/// 
/// /// Adjust the hit event threshold. Advanced feature for testing.
/// [ Internal="b2World_SetHitEventThreshold"] void setHitEventThreshold([Get="castWorldId"] WorldId worldId, float value);
/// 
/// /// Register the pre-solve callback. This is optional.
/// //[ Internal="b2World_SetPreSolveCallback"] void setPreSolveCallback([Get="castWorldId"] WorldId worldId, bool (ShapeId shapeIdA, ShapeId shapeIdB, Manifold manifold, dynamic context) PreSolveFcn, dynamic context);
/// 
/// /// Set the gravity vector for the entire world. Typically in m/s^2
/// [ Internal="hbox2c::World::SetGravity"] void setGravity([Get="castWorldId"] WorldId worldId, float x, float y);
/// 
/// /// @return the gravity vector
/// //[ Internal="b2World_GetGravity"] b2Vec2 getGravity([Get="castWorldId"] WorldId worldId);
/// 
/// /// Apply explosion
/// [ Internal="hbox2c::World::Explode"] void explode([Get="castWorldId"] WorldId worldId, float pos_x, float pos_y, float radius, float impulse);
/// 
/// /// Adjust contact tuning parameters:
/// /// - hertz is the contact stiffness (cycles per second)
/// /// - damping ratio is the contact bounciness with 1 being critical damping (non-dimensional)
/// /// - push velocity is the maximum contact constraint push out velocity (meters per second)
/// ///	Advanced feature
/// [ Internal="b2World_SetContactTuning"] void setContactTuning([Get="castWorldId"] WorldId worldId, float hertz, float dampingRatio, float pushVelocity);
/// 
/// /// Get the current profile
/// //[ Internal="b2World_GetProfile"] b2Profile getProfile([Get="castWorldId"] WorldId worldId);
/// 
/// /// Get counters and sizes
/// //[ Internal="b2World_GetCounters"] b2Counters getCounters([Get="castWorldId"] WorldId worldId);
/// 
/// /// Dump memory stats to box2d_memory.txt
/// [ Internal="b2World_DumpMemoryStats"] void dumpMemoryStats([Get="castWorldId"] WorldId worldId);
/// 
};

[Internal="hbox2c::WorldContext"]
object WorldContext {
	WorldContext new(int workerCount);
	
	void setGravity(float x, float y);

	/// Restitution velocity threshold, usually in m/s. Collisions above this
	/// speed have restitution applied (will bounce).
	attribute float restitutionThreshold;

	/// This parameter controls how fast overlap is resolved and has units of meters per second
	attribute float contactPushoutVelocity;

	/// Threshold velocity for hit events. Usually meters per second.
	attribute float hitEventThreshold;

	/// Contact stiffness. Cycles per second.
	attribute float contactHertz;

	/// Contact bounciness. Non-dimensional.
	attribute float contactDampingRatio;

	/// Joint stiffness. Cycles per second.
	attribute float jointHertz;

	/// Joint bounciness. Non-dimensional.
	attribute float jointDampingRatio;

	/// Can bodies go to sleep to improve performance
	attribute bool enableSleep;

	/// Enable continuous collision
	attribute bool enableContinous;

	/// task system hookup
	//attribute uint workerCount;

	World createWorld();
	void destroyWorld(World id);

	/// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.
	/// @param worldId the world to simulate
	/// @param timeStep the amount of time to simulate, this should be a fixed number. Typically 1/60.
	/// @param subStepCount the number of sub-steps, increasing the sub-step count can increase accuracy. Typically 4.
	void step( [Get="castWorldId"] World worldId, float timeStep, int subStepCount);


	[Static, Internal="hbox2c::WorldContext::EnableDebug"] void EnableDebug();
};
