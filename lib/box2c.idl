typedef WorldId uint;
typedef ShapeId int64;
typedef BodyId int64;
typedef QueryFilter int64;

/// The body type.
/// static: zero mass, zero velocity, may be manually moved
/// kinematic: zero mass, non-zero velocity set by user, moved by solver
/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver
[Internal="b2BodyType", Prefix="b2_"]
enum BodyType
{
	"staticBody",
	"kinematicBody",
	"dynamicBody"
};

[Internal="b2Vec2"]
interface Vec2 {
	void Vec2();
	attribute float x;
	attribute float y;
};

[Internal="b2AABB"]
interface AABB {
	void AABB();
	[Internal="lowerBound.x"] attribute float lowerBound_x;
	[Internal="lowerBound.y"] attribute float lowerBound_y;
	[Internal="upperBound.x"] attribute float upperBound_x;
	[Internal="upperBound.y"] attribute float upperBound_y;
};


[Internal="b2Transform"]
interface Transform {
	void Transform();

	[Internal="p.x"] attribute float x; 
	[Internal="p.y"] attribute float y;
	[Internal="q.c"] attribute float c; // cos
	[Internal="q.s"] attribute float s; // sin
};

[NoDelete, Internal="b2BodyMoveEvent"]
interface BodyMoveEvent
{
	[Internal="transform.p.x"] attribute float pos_x;
	[Internal="transform.p.y"] attribute float pos_y;
	[Internal="transform.q.c"] attribute float quat_c;
	[Internal="transform.q.s"] attribute float quat_s;
	[Get="cast", Set="castBodyId"] attribute BodyId bodyId;
	[Get="cast"] attribute dynamic userData;
	attribute bool fellAsleep;
};

/// Body events are buffered in the Box2D world and are available
///	as event arrays after the time step is complete.
///	Note: this date becomes invalid if bodies are destroyed
[Internal="hbox2c::BodyEvents"]
interface BodyEvents
{
	void getMove( int i, BodyMoveEvent moveEvent);
	attribute int moveCount;
};


/// A begin touch event is generated when a shape starts to overlap a sensor shape.
[NoDelete, Internal="hbox2c::SensorBeginTouchEvent"]
interface SensorBeginTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId sensorShapeId;
	[Get="cast", Set="castShapeId"] attribute ShapeId visitorShapeId;
};

/// An end touch event is generated when a shape stops overlapping a sensor shape.
[NoDelete, Internal="hbox2c::SensorEndTouchEvent"]
interface SensorEndTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId sensorShapeId;
	[Get="cast", Set="castShapeId"] attribute ShapeId visitorShapeId;
};

/// Sensor events are buffered in the Box2D world and are available
///	as begin/end overlap event arrays after the time step is complete.
///	Note: these may become invalid if bodies and/or shapes are destroyed
[Internal="hbox2c::SensorEvents"]
interface SensorEvents
{
	void SensorEvents();

	void getBegin( int i, SensorBeginTouchEvent event);
	void getEnd( int i, SensorEndTouchEvent event);

	attribute int beginCount;
	attribute int endCount;
} ;

/// A begin touch event is generated when two shapes begin touching. By convention the manifold
/// normal points from shape A to shape B.
[NoDelete, Internal="b2ContactBeginTouchEvent"]
interface ContactBeginTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;
} ;

/// An end touch event is generated when two shapes stop touching.
[NoDelete, Internal="b2ContactEndTouchEvent"]
interface ContactEndTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;
} ;

/// A hit touch event is generated when two shapes collide with a speed faster than the hit speed threshold.
[NoDelete, Internal="hbox2c::ContactHitEvent"]
interface ContactHitEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;

	// point where the shapes hit
	//b2Vec2 point;
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;

	// normal vector pointing from shape A to shape B
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.y"] attribute float normal_y;

	attribute float approachSpeed;
} ;

/// Contact events are buffered in the Box2D world and are available
///	as event arrays after the time step is complete.
///	Note: these may become invalid if bodies and/or shapes are destroyed
[Internal="hbox2c::ContactEvents"]
interface ContactEvents
{
	void getBegin( int i, ContactBeginTouchEvent event);
	void getEnd( int i, ContactEndTouchEvent event);
	void getHit( int i, ContactHitEvent event);

	attribute int beginCount;
	attribute int endCount;
	attribute int hitCount;
} ;

[Internal="hbox2c::RayResult"]
interface RayResult
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeId;
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.y"] attribute float normal_y;
	attribute float fraction;
	attribute bool hit;
};

[Internal="hbox2c::Hull"]
interface Hull 
{
	void Hull();

	void fromPoints(float [] points, int count);
    bool isValid();
};

[Internal="hbox2c::Polygon"]
interface Polygon 
{
	void Polygon();

	/// Make a convex polygon from a convex hull. This will assert if the hull is not valid.
	bool fromHull(Hull hull, float radius);

	/// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.
	bool fromOffsetHull(Hull hull, float radius, float transform_x, float transform_y, float transform_rot );

	/// Make a square polygon, bypassing the need for a convex hull.
	bool makeSquare(float h);

	/// Make a box (rectangle) polygon, bypassing the need for a convex hull.
	bool makeBox(float hx, float hy);

	/// Make a rounded box, bypassing the need for a convex hull.
	bool makeRoundedBox(float hx, float hy, float radius);

	/// Make an offset box, bypassing the need for a convex hull.
	bool makeOffsetBox(float hx, float hy, float center_x, float center_y, float angle);

	/// Transform a polygon. This is useful for transferring a shape from one body to another.
	bool fromTransformedPolygon(float transform_x, float transform_y, float transform_rot, Polygon polygon);
};

/// A body definition holds all the data needed to construct a rigid body.
/// You can safely re-use body definitions. Shapes are added to a body after construction.
[Internal="hbox2c::BodyDef"]
interface BodyDef {
	void BodyDef();
	
	/// The body type: static, kinematic, or dynamic.
	/// Note: if a dynamic body would have zero mass, the mass is set to one.
	attribute BodyType type;

	/// The world position of the body. Avoid creating bodies at the origin
	/// since this can lead to many overlapping shapes.
	void setPosition( float x, float y);

	/// The world angle of the body in radians.
	attribute float angle;

	/// The linear velocity of the body's origin in world co-ordinates.
	void setLinearVelocity( float x, float y);

	/// The angular velocity of the body.
	attribute float angularVelocity;

	/// Linear damping is use to reduce the linear velocity. The damping parameter
	/// can be larger than 1.0f but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	attribute float linearDamping;

	/// Angular damping is use to reduce the angular velocity. The damping parameter
	/// can be larger than 1.0f but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	attribute float angularDamping;

	/// Scale the gravity applied to this body.
	attribute float gravityScale;

	/// Sleep velocity threshold, default is 0.05 meter per second
	attribute float sleepThreshold;

	/// Use this to store application specific body data.
	void setUserData( dynamic data );

	/// Set this flag to false if this body should never fall asleep. Note that
	/// this increases CPU usage.
	attribute bool enableSleep;

	/// Is this body initially awake or sleeping?
	attribute bool isAwake;

	/// Should this body be prevented from rotating? Useful for characters.
	attribute bool fixedRotation;

	/// Treat this body as high speed object that performs continuous collision detection
	/// against dynamic and kinematic bodies, but not other bullet bodies.
	attribute bool isBullet;

	/// Does this body start out enabled?
	attribute bool isEnabled;

	/// Automatically compute mass and related properties on this body from shapes.
	/// Triggers whenever a shape is add/removed/changed. Default is true.
	attribute bool automaticMass;

};

[NoDelete]
interface BodyFunc {


/// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[Static, Internal="hbox2c::Body::CreateCircleShape", Get="cast"] ShapeId createCircleShape([Get="castBodyId"] BodyId bodyId, ShapeDef def, float center_x, float center_y, float radius);

/// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[Static, Internal="hbox2c::Body::CreateSegmentShape", Get="cast"] ShapeId createSegmentShape([Get="castBodyId"] BodyId bodyId, ShapeDef def, float point_1_x, float point_1_y, float point_2_x, float point_2_y);

/// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[Static, Internal="hbox2c::Body::CreateCapsuleShape", Get="cast"] ShapeId createCapsuleShape([Get="castBodyId"] BodyId bodyId, ShapeDef def, float center_1_x, float center_1_y, float center_2_x, float center_2_y, float radius);

/// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
// [Static, Internal="hbox2c::Body::CreatePolygonShape", Get="cast"] ShapeId createPolygonShape([Get="castBodyId"] BodyId bodyId, ShapeDef def, b2Polygon* polygon);

/// Destroy any shape type
 [Static, Internal="hbox2c::Body::DestroyShape"] void destroyShape([Get="castShapeId"]ShapeId shapeId);


 
/// Body identifier validation. Provides validation for up to 64K allocations.
[Static, Internal="b2Body_IsValid"] bool isValid([Get="castBodyId"] BodyId id);

/// Get the body type: static, kinematic, or dynamic
[Static, Internal="b2Body_GetType"] BodyType getType([Get="castBodyId"] BodyId bodyId);

/// Change the body type. This is an expensive operation. This automatically updates the mass
///	properties regardless of the automatic mass setting.
[Static, Internal="b2Body_SetType"] void setType([Get="castBodyId"] BodyId bodyId, BodyType type);

/// Set the user data for a body
[Static, Internal="b2Body_SetUserData"] void setUserData([Get="castBodyId"] BodyId bodyId, dynamic userData);

/// Get the user data stored in a body
[Static, Internal="b2Body_GetUserData", Get="cast"] dynamic getUserData([Get="castBodyId"] BodyId bodyId);

/// Get the world position of a body. This is the location of the body origin.
[Static, Internal="hbox2c::Body::GetPosition"] void getPosition([Get="castBodyId"] BodyId bodyId, Vec2 o_position);

/// Get the world rotation of a body as a sine/cosine pair.
[Static, Internal="hbox2c::Body::GetRotation"] void getRotation([Get="castBodyId"] BodyId bodyId, Vec2 quat);

/// Get the body angle in radians in the range [-pi, pi]
[Static, Internal="b2Body_GetAngle"] float getAngle([Get="castBodyId"] BodyId bodyId);

/// Get the world transform of a body.
[Static, Internal="hbox2c::Body::GetTransform"] void getTransform([Get="castBodyId"] BodyId bodyId, Transform transform);

/// Set the world transform of a body. This acts as a teleport and is fairly expensive.
[Static, Internal="hbox2c::Body::SetTransform"] void setTransform([Get="castBodyId"] BodyId bodyId, float position_x, float position_y, float angle);

/// Get a local point on a body given a world point
[Static, Internal="hbox2c::Body::GetLocalPoint"] void getLocalPoint([Get="castBodyId"] BodyId bodyId, float worldPoint_x, float worldPoint_y, Vec2 o_position );

/// Get a world point on a body given a local point
[Static, Internal="hbox2c::Body::GetWorldPoint"] void getWorldPoint([Get="castBodyId"] BodyId bodyId, float localPoint_x, float localPoint_y, Vec2 o_position );

/// Get a local vector on a body given a world vector
[Static, Internal="hbox2c::Body::GetLocalVector"] void getLocalVector([Get="castBodyId"] BodyId bodyId, float worldVector_x, float worldVector_y, Vec2 o_vector );

/// Get a world vector on a body given a local vector
[Static, Internal="hbox2c::Body::GetWorldVector"] void getWorldVector([Get="castBodyId"] BodyId bodyId, float localVector_x, float localVector_y, Vec2 o_vector );

/// Get the linear velocity of a body's center of mass
[Static, Internal="hbox2c::Body::GetLinearVelocity"] void getLinearVelocity([Get="castBodyId"] BodyId bodyId, Vec2 o_velocity);

/// Get the angular velocity of a body in radians per second
[Static, Internal="b2Body_GetAngularVelocity"] float getAngularVelocity([Get="castBodyId"] BodyId bodyId);

/// Set the linear velocity of a body
[Static, Internal="hbox2c::Body::SetLinearVelocity"] void setLinearVelocity([Get="castBodyId"] BodyId bodyId, float linearVelocity_x, float linearVelocity_y);

/// Set the angular velocity of a body in radians per second
[Static, Internal="b2Body_SetAngularVelocity"] void setAngularVelocity([Get="castBodyId"] BodyId bodyId, float angularVelocity);

/// Apply a force at a world point. If the force is not
/// applied at the center of mass, it will generate a torque and
/// affect the angular velocity. This wakes up the body.
/// @param force the world force vector, usually in Newtons (N).
/// @param point the world position of the point of application.
/// @param wake also wake up the body
[Static, Internal="hbox2c::Body::ApplyForce"] void applyForce([Get="castBodyId"]BodyId bodyId, float force_x, float force_y,  float point_x, float point_y, bool wake);

/// Apply a force to the center of mass. This wakes up the body.
/// @param force the world force vector, usually in Newtons (N).
/// @param wake also wake up the body
[Static, Internal="hbox2c::Body::ApplyForceToCenter"] void applyForceToCenter([Get="castBodyId"]BodyId bodyId, float force_x, float force_y, bool wake);

/// Apply a torque. This affects the angular velocity
/// without affecting the linear velocity of the center of mass.
/// @param torque about the z-axis (out of the screen), usually in N-m.
/// @param wake also wake up the body
[Static, Internal="b2Body_ApplyTorque"] void applyTorque([Get="castBodyId"]BodyId bodyId, float torque, bool wake);

/// Apply an impulse at a point. This immediately modifies the velocity.
/// It also modifies the angular velocity if the point of application
/// is not at the center of mass. This wakes up the body.
/// This should be used for one-shot impulses. If you need a steady force,
/// use a force instead, which will work better with the sub-stepping solver.
/// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
/// @param point the world position of the point of application.
/// @param wake also wake up the body
[Static, Internal="hbox2c::Body::ApplyLinearImpulse"] void applyLinearImpulse([Get="castBodyId"]BodyId bodyId, float impulse_x, float impulse_y, float point_x, float point_y, bool wake);

/// Apply an impulse to the center of mass. This immediately modifies the velocity.
/// This should be used for one-shot impulses. If you need a steady force,
/// use a force instead, which will work better with the sub-stepping solver.
/// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
/// @param wake also wake up the body
[Static, Internal="hbox2c::Body::ApplyLinearImpulseToCenter"] void applyLinearImpulseToCenter([Get="castBodyId"]BodyId bodyId, float impulse_x, float impulse_y, bool wake);

/// Apply an angular impulse.
/// This should be used for one-shot impulses. If you need a steady force,
/// use a force instead, which will work better with the sub-stepping solver.
/// @param impulse the angular impulse in units of
/// kg*m*m/s
/// @param wake also wake up the body
[Static, Internal="b2Body_ApplyAngularImpulse"] void applyAngularImpulse([Get="castBodyId"]BodyId bodyId, float impulse, bool wake);

/// Get the mass of the body (kilograms)
[Static, Internal="b2Body_GetMass"] float getMass([Get="castBodyId"]BodyId bodyId);

/// Get the inertia tensor of the body. In 2D this is a single number. (kilograms * meters^2)
[Static, Internal="b2Body_GetInertiaTensor"] float getInertiaTensor([Get="castBodyId"]BodyId bodyId);

/// Get the center of mass position of the body in local space.
[Static, Internal="hbox2c::Body::GetLocalCenterOfMass"] void getLocalCenterOfMass([Get="castBodyId"]BodyId bodyId, Vec2 o_centerOfMass);

/// Get the center of mass position of the body in world space.
[Static, Internal="hbox2c::Body::GetWorldCenterOfMass"] void getWorldCenterOfMass([Get="castBodyId"]BodyId bodyId, Vec2 o_centerOfMass);

/// Override the body's mass properties. Normally this is computed automatically using the
///	shape geometry and density. This information is lost if a shape is added or removed or if the
///	body type changes.
//[Static, Internal="b2Body_SetMassData"] void SetMassData([Get="castBodyId"]BodyId bodyId, b2MassData massData);

/// Get the mass data for a body.
//[Static, Internal="b2Body_GetMassData"] b2MassData GetMassData([Get="castBodyId"]BodyId bodyId);

/// This resets the mass properties to the sum of the mass properties of the shapes.
/// This normally does not need to be called unless you called SetMassData to override
/// the mass and you later want to reset the mass.
///	You may also use this when automatic mass computation has been disabled.
///	You should call this regardless of body type.
[Static, Internal="b2Body_ApplyMassFromShapes"] void applyMassFromShapes([Get="castBodyId"] BodyId bodyId);

/// Set the automatic mass setting.
//[Static, Internal="b2Body_SetAutomaticMass"] void setAutomaticMass([Get="castBodyId"]BodyId bodyId, bool automaticMass);

/// Get the automatic mass setting.
//[Static, Internal="b2Body_GetAutomaticMass"] bool getAutomaticMass([Get="castBodyId"]BodyId bodyId);

/// Adjust the linear damping. Normally this is set in b2BodyDef before creation.
[Static, Internal="b2Body_SetLinearDamping"] void SetLinearDamping([Get="castBodyId"]BodyId bodyId, float linearDamping);

/// Get the current linear damping.
[Static, Internal="b2Body_GetLinearDamping"] float getLinearDamping([Get="castBodyId"]BodyId bodyId);

/// Adjust the angular damping. Normally this is set in b2BodyDef before creation.
[Static, Internal="b2Body_SetAngularDamping"] void SetAngularDamping([Get="castBodyId"]BodyId bodyId, float angularDamping);

/// Get the current angular damping.
[Static, Internal="b2Body_GetAngularDamping"] float getAngularDamping([Get="castBodyId"]BodyId bodyId);

/// Adjust the gravity scale. Normally this is set in b2BodyDef before creation.
[Static, Internal="b2Body_SetGravityScale"] void SetGravityScale([Get="castBodyId"]BodyId bodyId, float gravityScale);

/// Get the current gravity scale.
[Static, Internal="b2Body_GetGravityScale"] float getGravityScale([Get="castBodyId"]BodyId bodyId);

/// Is this body awake?
[Static, Internal="b2Body_IsAwake"] bool isAwake([Get="castBodyId"]BodyId bodyId);

/// Wake a body from sleep. This wakes the entire island the body is touching.
///	Putting a body to sleep will put the entire island of bodies touching this body to sleep,
///	which can be expensive.
[Static, Internal="b2Body_SetAwake"] void setAwake([Get="castBodyId"]BodyId bodyId, bool awake);

/// Enable or disable sleeping this body. If sleeping is disabled the body will wake.
[Static, Internal="b2Body_EnableSleep"] void enableSleep([Get="castBodyId"]BodyId bodyId, bool enableSleep);

/// @return is sleeping enabled for this body?
[Static, Internal="b2Body_IsSleepEnabled"] bool isSleepEnabled([Get="castBodyId"]BodyId bodyId);

/// Set the sleep threshold. Normally in meters per second.
[Static, Internal="b2Body_SetSleepThreshold"] void setSleepThreshold([Get="castBodyId"]BodyId bodyId, float sleepVelocity);

/// Get the sleep threshold. Normally in meters per second.
[Static, Internal="b2Body_GetSleepThreshold"] float getSleepThreshold([Get="castBodyId"]BodyId bodyId);

/// Is this body enabled?
[Static, Internal="b2Body_IsEnabled"] bool isEnabled([Get="castBodyId"]BodyId bodyId);

/// Disable a body by removing it completely from the simulation
[Static, Internal="b2Body_Disable"] void disable([Get="castBodyId"]BodyId bodyId);

/// Enable a body by adding it to the simulation
[Static, Internal="b2Body_Enable"] void enable([Get="castBodyId"]BodyId bodyId);

/// Set this body to have fixed rotation. This causes the mass to be reset in all cases.
[Static, Internal="b2Body_SetFixedRotation"] void setFixedRotation([Get="castBodyId"]BodyId bodyId, bool flag);

/// Does this body have fixed rotation?
[Static, Internal="b2Body_IsFixedRotation"] bool isFixedRotation([Get="castBodyId"]BodyId bodyId);

/// Set this body to be a bullet. A bullet does continuous collision detection
/// against dynamic bodies (but not other bullets).
[Static, Internal="b2Body_SetBullet"] void setBullet([Get="castBodyId"]BodyId bodyId, bool flag);

/// Is this body a bullet?
[Static, Internal="b2Body_IsBullet"] bool isBullet([Get="castBodyId"]BodyId bodyId);

/// Enable/disable hit events on all shapes.
[Static, Internal="b2Body_EnableHitEvents"] void enableHitEvents([Get="castBodyId"]BodyId bodyId, bool enableHitEvents);

/// Get the number of shapes on this body
[Static, Internal="b2Body_GetShapeCount"] int getShapeCount([Get="castBodyId"]BodyId bodyId);

/// Get the shape ids for all shapes on this body, up to the provided capacity.
///	@returns the number of shape ids stored in the user array
//[Static, Internal="b2Body_GetShapes"] int getShapes([Get="castBodyId"]BodyId bodyId, b2ShapeId* shapeArray, int capacity);

/// Get the number of joints on this body
[Static, Internal="b2Body_GetJointCount"] int getJointCount([Get="castBodyId"]BodyId bodyId);

/// Get the joint ids for all joints on this body, up to the provided capacity
///	@returns the number of joint ids stored in the user array
//[Static, Internal="b2Body_GetJoints"] int getJoints([Get="castBodyId"]BodyId bodyId, b2JointId* jointArray, int capacity);

/// Get the maximum capacity required for retrieving all the touching contacts on a body
[Static, Internal="b2Body_GetContactCapacity"] int getContactCapacity([Get="castBodyId"]BodyId bodyId);

/// Get the touching contact data for a body
//[Static, Internal="b2Body_GetContactData"] int getContactData([Get="castBodyId"]BodyId bodyId, b2ContactData* contactData, int capacity);

/// Get the current world AABB that contains all the attached shapes. Note that this may not emcompass the body origin.
///	If there are no shapes attached then the returned AABB is empty and centered on the body origin.
[Static, Internal="hbox2c::Body::ComputeAABB"] void computeAABB([Get="castBodyId"]BodyId bodyId, AABB aabb);

};



/// Shape type
[Internal="b2ShapeType", Prefix="b2_"]
enum ShapeType
{
	"circleShape",
	"capsuleShape",
	"segmentShape",
	"polygonShape",
	"smoothSegmentShape",
	"shapeTypeCount"
} ;

/// This holds contact filtering data.
interface b2Filter
{
	/// The collision category bits. Normally you would just set one bit.
	attribute uint categoryBits;

	/// The collision mask bits. This states the categories that this
	/// shape would accept for collision.
	attribute uint maskBits;

	/// Collision groups allow a certain group of objects to never collide (negative)
	/// or always collide (positive). Zero means no collision group. Non-zero group
	/// filtering always wins against the mask bits.
	attribute int groupIndex;
} ;

/// Used to create a shape
[Internal="hbox2c::ShapeDef"]
interface ShapeDef
{
	void ShapeDef();

	/// Use this to store application specific shape data.
	[Get="cast"] attribute dynamic userData;

	/// The friction coefficient, usually in the range [0,1].
	attribute float friction;

	/// The restitution (bounce) usually in the range [0,1].
	attribute float restitution;

	/// The density, usually in kg/m^2.
	attribute float density;

	/// Contact filtering data.
	//attribute b2Filter filter;
	[Internal="filter.categoryBits"] attribute uint categoryBits;
	[Internal="filter.maskBits"] attribute uint maskBits;
	[Internal="filter.groupIndex"] attribute int groupIndex;

	/// A sensor shape collects contact information but never generates a collision response.
	attribute bool isSensor;

	/// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableSensorEvents;

	/// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableContactEvents;

	/// Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableHitEvents;

	/// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
	///	and must be carefully handled due to multi-threading. Ignored for sensors.
	attribute bool enablePreSolveEvents;

	/// Normally shapes on static bodies don't invoke contact creation when they are added to the world. This overrides
	///	that behavior and causes contact creation. This significantly slows down static body creation which can be important
	///	when there are many static bodies.
	attribute bool forceContactCreation;

} ;


/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
[NoDelete, Internal="hbox2c::ManifoldPoint"]
interface ManifoldPoint
{
	/// Location of the contact point in world space. Subject to precision loss at large coordinates.
	///	@warning should only be used for debugging.
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;

	/// Location of contact point relative to body origin in world space.
	///	@warning when used internally to the Box2D solver, these are relative to the center of mass.
	[Internal="anchorA.x"] attribute float anchorA_x;
	[Internal="anchorA.y"] attribute float anchorA_y;
	[Internal="anchorB.x"] attribute float anchorB_x;
	[Internal="anchorB.y"] attribute float anchorB_y;

	/// the separation of the contact point, negative if penetrating
	attribute float separation;

	/// the non-penetration impulse
	attribute float normalImpulse;

	/// the friction impulse
	attribute float tangentImpulse;

	/// the maximum normal impulse applied during sub-stepping
	///	todo not sure this is needed
	attribute float maxNormalImpulse;

	/// Relative normal velocity pre-solve. Used for hit events. If the normal impulse is
	/// zero then there was no hit. Negative means shapes are approaching.
	attribute float normalVelocity;

	/// uniquely identifies a contact point between two shapes
	attribute int id;

	/// Did this contact point exist the previous step?
	attribute bool persisted;
} ;

/// Contact manifold convex shapes.
[Internal="hbox2c::Manifold"]
interface Manifold
{
	[AddressOf, ReadOnly, Const, Internal="points[0]", GetCast="hbox2c::ManifoldPoint*"] attribute ManifoldPoint points0;
	[AddressOf, ReadOnly, Const, Internal="points[1]", GetCast="hbox2c::ManifoldPoint*"] attribute ManifoldPoint points1;
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.x"] attribute float normal_y;
	attribute int pointCount;
} ;


/// Prototype for a pre-solve callback.
/// This is called after a contact is updated. This allows you to inspect a
/// contact before it goes to the solver. If you are careful, you can modify the
/// contact manifold (e.g. disable contact).
/// Notes:
///	- this function must be thread-safe
///	- this is only called if the shape has enabled presolve events
/// - this is called only for awake dynamic bodies
/// - this is not called for sensors
/// - the supplied manifold has impulse values from the previous step
///	Return false if you want to disable the contact this step
//typedef bool b2PreSolveFcn(b2ShapeId shapeIdA, b2ShapeId shapeIdB, b2Manifold* manifold, void* context);

//bool (ShapeId shapeIdA, ShapeId shapeIdB, Manifold manifold, dynamic context) PreSolveFcn

[NoDelete]
interface WorldFunc {

/// Destroy a world.
[Static, Internal="b2DestroyWorld"] void destroy([Get="castWorldId"] WorldId worldId);

/// World identifier validation. Provides validation for up to 64K allocations.
[Static, Internal="b2World_IsValid"] bool isValid([Get="castWorldId"] WorldId id);


/// Call this to draw shapes and other debug draw data. This is intentionally non-const.
//[Static, Internal="b2World_Draw"] void draw([Get="castWorldId"] WorldId worldId, b2DebugDraw* draw);

/// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.
[Static, Internal="hbox2c::World::GetBodyEvents"] void getBodyEvents([Get="castWorldId"]WorldId worldId, BodyEvents events);

/// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.
[Static, Internal="hbox2c::World::GetSensorEvents"] void getSensorEvents([Get="castWorldId"]WorldId worldId, SensorEvents sensorEvents);

/// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.
[Static, Internal="hbox2c::World::GetContactEvents"] void getContactEvents([Get="castWorldId"]WorldId worldId, ContactEvents contactEvents);

/// Overlap test for all shapes that *potentially* overlap the provided AABB.
[Static, Internal="hbox2c::World::OverlapAABB"] void overlapAABB([Get="castWorldId"]WorldId worldId, float min_x, float min_y, float max_x, float max_y, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// Overlap test for for all shapes that overlap the provided circle.
[Static, Internal="hbox2c::World::OverlapCircle"] void overlapCircle([Get="castWorldId"]WorldId worldId, float x, float y, float radius,  Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// Overlap test for all shapes that overlap the provided capsule.
//[Static, Internal="hbox2c::World::OverlapCapsule"] void overlapCapsule([Get="castWorldId"] WorldId worldId, const b2Capsule* capsule, Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// Overlap test for all shapes that overlap the provided polygon.
//[Static, Internal="hbox2c::World::OverlapPolygon"] void overlapPolygon([Get="castWorldId"] WorldId worldId, const b2Polygon* polygon, Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// Ray-cast the world for all shapes in the path of the ray. Your callback
/// controls whether you get the closest point, any point, or n-points.
/// The ray-cast ignores shapes that contain the starting point.
/// @param callback a user implemented callback class.
/// @param point1 the ray starting point
/// @param point2 the ray ending point
[Static, Internal="hbox2c::World::RayCast"] void rayCast([Get="castWorldId"] WorldId worldId, float x, float y, float dx, float dy, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);

/// Ray-cast closest hit. Convenience function. This is less general than b2World_RayCast and does not allow for custom filtering.
[Static, Internal="hbox2c::World::RayCastClosest"] bool rayCastClosest([Get="castWorldId"] WorldId worldId, float origin_x, float origin_y, float translation_x, float translation_y, [Get="castQueryFilter"] QueryFilter filter, RayResult result);

/// Cast a circle through the world. Similar to a ray-cast except that a circle is cast instead of a point.
[Static, Internal="hbox2c::World::CircleCast"] void circleCast([Get="castWorldId"] WorldId worldId, float x, float y, float radius, float ox, float oy, float rot, float dx, float dy,[Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);

/// Cast a capsule through the world. Similar to a ray-cast except that a capsule is cast instead of a point.
//[Static, Internal="b2World_CapsuleCast"] void capsuleCast([Get="castWorldId"] WorldId worldId, const b2Capsule* capsule, Transform originTransform, b2Vec2 translation, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);

/// Cast a capsule through the world. Similar to a ray-cast except that a polygon is cast instead of a point.
//[Static, Internal="b2World_PolygonCast"] void polygonCast([Get="castWorldId"] WorldId worldId, const b2Polygon* polygon, Transform originTransform, b2Vec2 translation, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);

/// Enable/disable sleep. Advanced feature for testing.
[Static, Internal="b2World_EnableSleeping"] void enableSleeping([Get="castWorldId"] WorldId worldId, bool flag);

/// Enable/disable constraint warm starting. Advanced feature for testing.
[Static, Internal="b2World_EnableWarmStarting"] void enableWarmStarting([Get="castWorldId"] WorldId worldId, bool flag);

/// Enable/disable continuous collision. Advanced feature for testing.
[Static, Internal="b2World_EnableContinuous"] void enableContinuous([Get="castWorldId"] WorldId worldId, bool flag);

/// Adjust the restitution threshold. Advanced feature for testing.
[Static, Internal="b2World_SetRestitutionThreshold"] void setRestitutionThreshold([Get="castWorldId"] WorldId worldId, float value);

/// Adjust the hit event threshold. Advanced feature for testing.
[Static, Internal="b2World_SetHitEventThreshold"] void setHitEventThreshold([Get="castWorldId"] WorldId worldId, float value);

/// Register the pre-solve callback. This is optional.
//[Static, Internal="b2World_SetPreSolveCallback"] void setPreSolveCallback([Get="castWorldId"] WorldId worldId, bool (ShapeId shapeIdA, ShapeId shapeIdB, Manifold manifold, dynamic context) PreSolveFcn, dynamic context);

/// Set the gravity vector for the entire world. Typically in m/s^2
[Static, Internal="hbox2c::World::SetGravity"] void setGravity([Get="castWorldId"] WorldId worldId, float x, float y);

/// @return the gravity vector
//[Static, Internal="b2World_GetGravity"] b2Vec2 getGravity([Get="castWorldId"] WorldId worldId);

/// Apply explosion
[Static, Internal="hbox2c::World::Explode"] void explode([Get="castWorldId"] WorldId worldId, float pos_x, float pos_y, float radius, float impulse);

/// Adjust contact tuning parameters:
/// - hertz is the contact stiffness (cycles per second)
/// - damping ratio is the contact bounciness with 1 being critical damping (non-dimensional)
/// - push velocity is the maximum contact constraint push out velocity (meters per second)
///	Advanced feature
[Static, Internal="b2World_SetContactTuning"] void setContactTuning([Get="castWorldId"] WorldId worldId, float hertz, float dampingRatio, float pushVelocity);

/// Get the current profile
//[Static, Internal="b2World_GetProfile"] b2Profile getProfile([Get="castWorldId"] WorldId worldId);

/// Get counters and sizes
//[Static, Internal="b2World_GetCounters"] b2Counters getCounters([Get="castWorldId"] WorldId worldId);

/// Dump memory stats to box2d_memory.txt
[Static, Internal="b2World_DumpMemoryStats"] void dumpMemoryStats([Get="castWorldId"] WorldId worldId);

[Static, Internal="b2CreateBody", Get="cast"] BodyId createBody([Get="castWorldId"] WorldId worldId, BodyDef def);
};

[Internal="hbox2c::WorldContext"]
interface WorldContext {
	void WorldContext(int workerCount);
	
	void setGravity(float x, float y);

	/// Restitution velocity threshold, usually in m/s. Collisions above this
	/// speed have restitution applied (will bounce).
	attribute float restitutionThreshold;

	/// This parameter controls how fast overlap is resolved and has units of meters per second
	attribute float contactPushoutVelocity;

	/// Threshold velocity for hit events. Usually meters per second.
	attribute float hitEventThreshold;

	/// Contact stiffness. Cycles per second.
	attribute float contactHertz;

	/// Contact bounciness. Non-dimensional.
	attribute float contactDampingRatio;

	/// Joint stiffness. Cycles per second.
	attribute float jointHertz;

	/// Joint bounciness. Non-dimensional.
	attribute float jointDampingRatio;

	/// Can bodies go to sleep to improve performance
	attribute bool enableSleep;

	/// Enable continuous collision
	attribute bool enableContinous;

	/// task system hookup
	//attribute uint workerCount;

	WorldId createWorld();
	void destroyWorld(WorldId id);

	/// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.
	/// @param worldId the world to simulate
	/// @param timeStep the amount of time to simulate, this should be a fixed number. Typically 1/60.
	/// @param subStepCount the number of sub-steps, increasing the sub-step count can increase accuracy. Typically 4.
	void step( [Get="castWorldId"] WorldId worldId, float timeStep, int subStepCount);


	[Static, Internal="hbox2c::WorldContext::EnableDebug"] void EnableDebug();
};
