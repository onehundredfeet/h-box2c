typedef WorldId uint;
typedef ShapeId int64;
typedef BodyId int64;
typedef QueryFilter int64;

/// The body type.
/// static: zero mass, zero velocity, may be manually moved
/// kinematic: zero mass, non-zero velocity set by user, moved by solver
/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver
[Internal="b2BodyType", Prefix="b2_"]
enum BodyType
{
	"staticBody",
	"kinematicBody",
	"dynamicBody"
};


[Internal="b2Transform"]
interface Transform {
	void Transform();

	[Internal="p.x"] attribute float x; 
	[Internal="p.y"] attribute float y;
	[Internal="q.c"] attribute float c; // cos
	[Internal="q.s"] attribute float s; // sin
};

[NoDelete, Internal="b2BodyMoveEvent"]
interface BodyMoveEvent
{
	[Internal="transform.p.x"] attribute float pos_x;
	[Internal="transform.p.y"] attribute float pos_y;
	[Internal="transform.q.c"] attribute float quat_c;
	[Internal="transform.q.s"] attribute float quat_s;
	[Get="cast", Set="castBodyId"] attribute BodyId bodyId;
	[Get="cast"] attribute dynamic userData;
	attribute bool fellAsleep;
};

/// Body events are buffered in the Box2D world and are available
///	as event arrays after the time step is complete.
///	Note: this date becomes invalid if bodies are destroyed
[Internal="hbox2c::BodyEvents"]
interface BodyEvents
{
	void getMove( int i, BodyMoveEvent moveEvent);
	attribute int moveCount;
};


/// A begin touch event is generated when a shape starts to overlap a sensor shape.
[NoDelete, Internal="hbox2c::SensorBeginTouchEvent"]
interface SensorBeginTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId sensorShapeId;
	[Get="cast", Set="castShapeId"] attribute ShapeId visitorShapeId;
};

/// An end touch event is generated when a shape stops overlapping a sensor shape.
[NoDelete, Internal="hbox2c::SensorEndTouchEvent"]
interface SensorEndTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId sensorShapeId;
	[Get="cast", Set="castShapeId"] attribute ShapeId visitorShapeId;
};

/// Sensor events are buffered in the Box2D world and are available
///	as begin/end overlap event arrays after the time step is complete.
///	Note: these may become invalid if bodies and/or shapes are destroyed
[Internal="hbox2c::SensorEvents"]
interface SensorEvents
{
	void SensorEvents();

	void getBegin( int i, SensorBeginTouchEvent event);
	void getEnd( int i, SensorEndTouchEvent event);

	attribute int beginCount;
	attribute int endCount;
} ;

/// A begin touch event is generated when two shapes begin touching. By convention the manifold
/// normal points from shape A to shape B.
[NoDelete, Internal="b2ContactBeginTouchEvent"]
interface ContactBeginTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;
} ;

/// An end touch event is generated when two shapes stop touching.
[NoDelete, Internal="b2ContactEndTouchEvent"]
interface ContactEndTouchEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;
} ;

/// A hit touch event is generated when two shapes collide with a speed faster than the hit speed threshold.
[NoDelete, Internal="hbox2c::ContactHitEvent"]
interface ContactHitEvent
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdA;
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeIdB;

	// point where the shapes hit
	//b2Vec2 point;
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;

	// normal vector pointing from shape A to shape B
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.y"] attribute float normal_y;

	attribute float approachSpeed;
} ;

/// Contact events are buffered in the Box2D world and are available
///	as event arrays after the time step is complete.
///	Note: these may become invalid if bodies and/or shapes are destroyed
[Internal="hbox2c::ContactEvents"]
interface ContactEvents
{
	void getBegin( int i, ContactBeginTouchEvent event);
	void getEnd( int i, ContactEndTouchEvent event);
	void getHit( int i, ContactHitEvent event);

	attribute int beginCount;
	attribute int endCount;
	attribute int hitCount;
} ;

[Internal="hbox2c::RayResult"]
interface RayResult
{
	[Get="cast", Set="castShapeId"] attribute ShapeId shapeId;
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.y"] attribute float normal_y;
	attribute float fraction;
	attribute bool hit;
};

/// A body definition holds all the data needed to construct a rigid body.
/// You can safely re-use body definitions. Shapes are added to a body after construction.
[Internal="hbox2c::BodyDef"]
interface BodyDef {
	void BodyDef();
	
	/// The body type: static, kinematic, or dynamic.
	/// Note: if a dynamic body would have zero mass, the mass is set to one.
	attribute BodyType type;

	/// The world position of the body. Avoid creating bodies at the origin
	/// since this can lead to many overlapping shapes.
	void setPosition( float x, float y);

	/// The world angle of the body in radians.
	attribute float angle;

	/// The linear velocity of the body's origin in world co-ordinates.
	void setLinearVelocity( float x, float y);

	/// The angular velocity of the body.
	attribute float angularVelocity;

	/// Linear damping is use to reduce the linear velocity. The damping parameter
	/// can be larger than 1.0f but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	attribute float linearDamping;

	/// Angular damping is use to reduce the angular velocity. The damping parameter
	/// can be larger than 1.0f but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	attribute float angularDamping;

	/// Scale the gravity applied to this body.
	attribute float gravityScale;

	/// Sleep velocity threshold, default is 0.05 meter per second
	attribute float sleepThreshold;

	/// Use this to store application specific body data.
	void setUserData( dynamic data );

	/// Set this flag to false if this body should never fall asleep. Note that
	/// this increases CPU usage.
	attribute bool enableSleep;

	/// Is this body initially awake or sleeping?
	attribute bool isAwake;

	/// Should this body be prevented from rotating? Useful for characters.
	attribute bool fixedRotation;

	/// Treat this body as high speed object that performs continuous collision detection
	/// against dynamic and kinematic bodies, but not other bullet bodies.
	attribute bool isBullet;

	/// Does this body start out enabled?
	attribute bool isEnabled;

	/// Automatically compute mass and related properties on this body from shapes.
	/// Triggers whenever a shape is add/removed/changed. Default is true.
	attribute bool automaticMass;

};

[NoDelete]
interface Body {


/// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[Static, Internal="hbox2c::Body::CreateCircleShape", Get="cast"] ShapeId createCircleShape([Get="castBodyId"] BodyId bodyId, ShapeDef def, float center_x, float center_y, float radius);

/// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[Static, Internal="hbox2c::Body::CreateSegmentShape", Get="cast"] ShapeId createSegmentShape([Get="castBodyId"] BodyId bodyId, ShapeDef def, float point_1_x, float point_1_y, float point_2_x, float point_2_y);

/// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
[Static, Internal="hbox2c::Body::CreateCapsuleShape", Get="cast"] ShapeId createCapsuleShape([Get="castBodyId"] BodyId bodyId, ShapeDef def, float center_1_x, float center_1_y, float center_2_x, float center_2_y, float radius);

/// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.
/// Contacts are not created until the next time step.
///	@return the shape id for accessing the shape
// [Static, Internal="hbox2c::Body::CreatePolygonShape", Get="cast"] ShapeId createPolygonShape([Get="castBodyId"] BodyId bodyId, ShapeDef def, b2Polygon* polygon);

/// Destroy any shape type
 [Static, Internal="hbox2c::Body::DestroyShape"] void destroyShape([Get="castShapeId"]ShapeId shapeId);
};



/// Shape type
[Internal="b2ShapeType", Prefix="b2_"]
enum ShapeType
{
	"circleShape",
	"capsuleShape",
	"segmentShape",
	"polygonShape",
	"smoothSegmentShape",
	"shapeTypeCount"
} ;

/// This holds contact filtering data.
interface b2Filter
{
	/// The collision category bits. Normally you would just set one bit.
	attribute uint categoryBits;

	/// The collision mask bits. This states the categories that this
	/// shape would accept for collision.
	attribute uint maskBits;

	/// Collision groups allow a certain group of objects to never collide (negative)
	/// or always collide (positive). Zero means no collision group. Non-zero group
	/// filtering always wins against the mask bits.
	attribute int groupIndex;
} ;

/// Used to create a shape
[Internal="hbox2c::ShapeDef"]
interface ShapeDef
{
	void ShapeDef();

	/// Use this to store application specific shape data.
	[Get="cast"] attribute dynamic userData;

	/// The friction coefficient, usually in the range [0,1].
	attribute float friction;

	/// The restitution (bounce) usually in the range [0,1].
	attribute float restitution;

	/// The density, usually in kg/m^2.
	attribute float density;

	/// Contact filtering data.
	//attribute b2Filter filter;
	[Internal="filter.categoryBits"] attribute uint categoryBits;
	[Internal="filter.maskBits"] attribute uint maskBits;
	[Internal="filter.groupIndex"] attribute int groupIndex;

	/// A sensor shape collects contact information but never generates a collision response.
	attribute bool isSensor;

	/// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableSensorEvents;

	/// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableContactEvents;

	/// Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	attribute bool enableHitEvents;

	/// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
	///	and must be carefully handled due to multi-threading. Ignored for sensors.
	attribute bool enablePreSolveEvents;

	/// Normally shapes on static bodies don't invoke contact creation when they are added to the world. This overrides
	///	that behavior and causes contact creation. This significantly slows down static body creation which can be important
	///	when there are many static bodies.
	attribute bool forceContactCreation;

} ;


/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
[NoDelete, Internal="hbox2c::ManifoldPoint"]
interface ManifoldPoint
{
	/// Location of the contact point in world space. Subject to precision loss at large coordinates.
	///	@warning should only be used for debugging.
	[Internal="point.x"] attribute float point_x;
	[Internal="point.y"] attribute float point_y;

	/// Location of contact point relative to body origin in world space.
	///	@warning when used internally to the Box2D solver, these are relative to the center of mass.
	[Internal="anchorA.x"] attribute float anchorA_x;
	[Internal="anchorA.y"] attribute float anchorA_y;
	[Internal="anchorB.x"] attribute float anchorB_x;
	[Internal="anchorB.y"] attribute float anchorB_y;

	/// the separation of the contact point, negative if penetrating
	attribute float separation;

	/// the non-penetration impulse
	attribute float normalImpulse;

	/// the friction impulse
	attribute float tangentImpulse;

	/// the maximum normal impulse applied during sub-stepping
	///	todo not sure this is needed
	attribute float maxNormalImpulse;

	/// Relative normal velocity pre-solve. Used for hit events. If the normal impulse is
	/// zero then there was no hit. Negative means shapes are approaching.
	attribute float normalVelocity;

	/// uniquely identifies a contact point between two shapes
	attribute int id;

	/// Did this contact point exist the previous step?
	attribute bool persisted;
} ;

/// Contact manifold convex shapes.
[Internal="hbox2c::Manifold"]
interface Manifold
{
	[AddressOf, ReadOnly, Const, Internal="points[0]", GetCast="hbox2c::ManifoldPoint*"] attribute ManifoldPoint points0;
	[AddressOf, ReadOnly, Const, Internal="points[1]", GetCast="hbox2c::ManifoldPoint*"] attribute ManifoldPoint points1;
	[Internal="normal.x"] attribute float normal_x;
	[Internal="normal.x"] attribute float normal_y;
	attribute int pointCount;
} ;


/// Prototype for a pre-solve callback.
/// This is called after a contact is updated. This allows you to inspect a
/// contact before it goes to the solver. If you are careful, you can modify the
/// contact manifold (e.g. disable contact).
/// Notes:
///	- this function must be thread-safe
///	- this is only called if the shape has enabled presolve events
/// - this is called only for awake dynamic bodies
/// - this is not called for sensors
/// - the supplied manifold has impulse values from the previous step
///	Return false if you want to disable the contact this step
//typedef bool b2PreSolveFcn(b2ShapeId shapeIdA, b2ShapeId shapeIdB, b2Manifold* manifold, void* context);

//bool (ShapeId shapeIdA, ShapeId shapeIdB, Manifold manifold, dynamic context) PreSolveFcn

[NoDelete]
interface World {

/// Destroy a world.
[Static, Internal="b2DestroyWorld"] void destroy([Get="castWorldId"] WorldId worldId);

/// World identifier validation. Provides validation for up to 64K allocations.
[Static, Internal="b2World_IsValid"] bool isValid([Get="castWorldId"] WorldId id);


/// Call this to draw shapes and other debug draw data. This is intentionally non-const.
//[Static, Internal="b2World_Draw"] void draw([Get="castWorldId"] WorldId worldId, b2DebugDraw* draw);

/// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.
[Static, Internal="hbox2c::World::GetBodyEvents"] void getBodyEvents([Get="castWorldId"]WorldId worldId, BodyEvents events);

/// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.
[Static, Internal="hbox2c::World::GetSensorEvents"] void getSensorEvents([Get="castWorldId"]WorldId worldId, SensorEvents sensorEvents);

/// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.
[Static, Internal="hbox2c::World::GetContactEvents"] void getContactEvents([Get="castWorldId"]WorldId worldId, ContactEvents contactEvents);

/// Overlap test for all shapes that *potentially* overlap the provided AABB.
[Static, Internal="hbox2c::World::OverlapAABB"] void overlapAABB([Get="castWorldId"]WorldId worldId, float min_x, float min_y, float max_x, float max_y, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// Overlap test for for all shapes that overlap the provided circle.
[Static, Internal="hbox2c::World::OverlapCircle"] void overlapCircle([Get="castWorldId"]WorldId worldId, float x, float y, float radius,  Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// Overlap test for all shapes that overlap the provided capsule.
//[Static, Internal="hbox2c::World::OverlapCapsule"] void overlapCapsule([Get="castWorldId"] WorldId worldId, const b2Capsule* capsule, Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// Overlap test for all shapes that overlap the provided polygon.
//[Static, Internal="hbox2c::World::OverlapPolygon"] void overlapPolygon([Get="castWorldId"] WorldId worldId, const b2Polygon* polygon, Transform transform, [Get="castQueryFilter"] QueryFilter filter, bool  (ShapeId shape, dynamic context) fcn, dynamic context);

/// Ray-cast the world for all shapes in the path of the ray. Your callback
/// controls whether you get the closest point, any point, or n-points.
/// The ray-cast ignores shapes that contain the starting point.
/// @param callback a user implemented callback class.
/// @param point1 the ray starting point
/// @param point2 the ray ending point
[Static, Internal="hbox2c::World::RayCast"] void rayCast([Get="castWorldId"] WorldId worldId, float x, float y, float dx, float dy, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);

/// Ray-cast closest hit. Convenience function. This is less general than b2World_RayCast and does not allow for custom filtering.
[Static, Internal="hbox2c::World::RayCastClosest"] bool rayCastClosest([Get="castWorldId"] WorldId worldId, float origin_x, float origin_y, float translation_x, float translation_y, [Get="castQueryFilter"] QueryFilter filter, RayResult result);

/// Cast a circle through the world. Similar to a ray-cast except that a circle is cast instead of a point.
[Static, Internal="hbox2c::World::CircleCast"] void circleCast([Get="castWorldId"] WorldId worldId, float x, float y, float radius, float ox, float oy, float rot, float dx, float dy,[Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);

/// Cast a capsule through the world. Similar to a ray-cast except that a capsule is cast instead of a point.
//[Static, Internal="b2World_CapsuleCast"] void capsuleCast([Get="castWorldId"] WorldId worldId, const b2Capsule* capsule, Transform originTransform, b2Vec2 translation, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);

/// Cast a capsule through the world. Similar to a ray-cast except that a polygon is cast instead of a point.
//[Static, Internal="b2World_PolygonCast"] void polygonCast([Get="castWorldId"] WorldId worldId, const b2Polygon* polygon, Transform originTransform, b2Vec2 translation, [Get="castQueryFilter"] QueryFilter filter, float (ShapeId shapeId, float p_x, float p_y, float n_x, float n_y, float fraction, dynamic context) fcn, dynamic context);

/// Enable/disable sleep. Advanced feature for testing.
[Static, Internal="b2World_EnableSleeping"] void enableSleeping([Get="castWorldId"] WorldId worldId, bool flag);

/// Enable/disable constraint warm starting. Advanced feature for testing.
[Static, Internal="b2World_EnableWarmStarting"] void enableWarmStarting([Get="castWorldId"] WorldId worldId, bool flag);

/// Enable/disable continuous collision. Advanced feature for testing.
[Static, Internal="b2World_EnableContinuous"] void enableContinuous([Get="castWorldId"] WorldId worldId, bool flag);

/// Adjust the restitution threshold. Advanced feature for testing.
[Static, Internal="b2World_SetRestitutionThreshold"] void setRestitutionThreshold([Get="castWorldId"] WorldId worldId, float value);

/// Adjust the hit event threshold. Advanced feature for testing.
[Static, Internal="b2World_SetHitEventThreshold"] void setHitEventThreshold([Get="castWorldId"] WorldId worldId, float value);

/// Register the pre-solve callback. This is optional.
//[Static, Internal="b2World_SetPreSolveCallback"] void setPreSolveCallback([Get="castWorldId"] WorldId worldId, bool (ShapeId shapeIdA, ShapeId shapeIdB, Manifold manifold, dynamic context) PreSolveFcn, dynamic context);

/// Set the gravity vector for the entire world. Typically in m/s^2
[Static, Internal="hbox2c::World::SetGravity"] void setGravity([Get="castWorldId"] WorldId worldId, float x, float y);

/// @return the gravity vector
//[Static, Internal="b2World_GetGravity"] b2Vec2 getGravity([Get="castWorldId"] WorldId worldId);

/// Apply explosion
[Static, Internal="hbox2c::World::Explode"] void explode([Get="castWorldId"] WorldId worldId, float pos_x, float pos_y, float radius, float impulse);

/// Adjust contact tuning parameters:
/// - hertz is the contact stiffness (cycles per second)
/// - damping ratio is the contact bounciness with 1 being critical damping (non-dimensional)
/// - push velocity is the maximum contact constraint push out velocity (meters per second)
///	Advanced feature
[Static, Internal="b2World_SetContactTuning"] void setContactTuning([Get="castWorldId"] WorldId worldId, float hertz, float dampingRatio, float pushVelocity);

/// Get the current profile
//[Static, Internal="b2World_GetProfile"] b2Profile getProfile([Get="castWorldId"] WorldId worldId);

/// Get counters and sizes
//[Static, Internal="b2World_GetCounters"] b2Counters getCounters([Get="castWorldId"] WorldId worldId);

/// Dump memory stats to box2d_memory.txt
[Static, Internal="b2World_DumpMemoryStats"] void dumpMemoryStats([Get="castWorldId"] WorldId worldId);

[Static, Internal="b2CreateBody", Get="cast"] BodyId createBody([Get="castWorldId"] WorldId worldId, BodyDef def);
};

[Internal="hbox2c::WorldContext"]
interface WorldContext {
	void WorldContext(int workerCount);
	
	void setGravity(float x, float y);

	/// Restitution velocity threshold, usually in m/s. Collisions above this
	/// speed have restitution applied (will bounce).
	attribute float restitutionThreshold;

	/// This parameter controls how fast overlap is resolved and has units of meters per second
	attribute float contactPushoutVelocity;

	/// Threshold velocity for hit events. Usually meters per second.
	attribute float hitEventThreshold;

	/// Contact stiffness. Cycles per second.
	attribute float contactHertz;

	/// Contact bounciness. Non-dimensional.
	attribute float contactDampingRatio;

	/// Joint stiffness. Cycles per second.
	attribute float jointHertz;

	/// Joint bounciness. Non-dimensional.
	attribute float jointDampingRatio;

	/// Can bodies go to sleep to improve performance
	attribute bool enableSleep;

	/// Enable continuous collision
	attribute bool enableContinous;

	/// task system hookup
	//attribute uint workerCount;

	WorldId createWorld();
	void destroyWorld(WorldId id);

	/// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.
	/// @param worldId the world to simulate
	/// @param timeStep the amount of time to simulate, this should be a fixed number. Typically 1/60.
	/// @param subStepCount the number of sub-steps, increasing the sub-step count can increase accuracy. Typically 4.
	void step( [Get="castWorldId"] WorldId worldId, float timeStep, int subStepCount);


	[Static, Internal="hbox2c::WorldContext::EnableDebug"] void EnableDebug();
};
